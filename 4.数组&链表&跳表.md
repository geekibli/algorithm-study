# 数组&链表&跳表



> **参考链接**
>
> - [Redis 设计与实现（第一版）](http://origin.redisbook.com/)
> - [LRU缓存算法](https://www.jianshu.com/p/b1ab4a170c3c)
> - [LRU 缓存](https://leetcode.cn/problems/lru-cache/) 
> - [为啥 redis 使用跳表(skiplist)而不是使用 red-black？](https://www.zhihu.com/question/20202931)



## 数组



### 数组在内存上是如何分配的





## 链表



链表在内存结构





## 跳表

对链表的增强

加速链表随机访问的时间

**加速的中心思想**： 升维，空间换时间



![](https://oscimg.oschina.net/oscnet/up-4b32f7ca62b318cae88410f168b1a817ae8.png)



首先，原始索引，是一个节点一个节点向后面遍历的，这样效率会比较差。

那添加了尾指针，可以一定程度上改善，效果不佳。

那么，可不可以加一个中指针呢？

比如，上面图中的，**第一级指针**，它的节点，提供一个中指针，指向，`value=4`的节点，也就是第三个节点。

那么，如果要查找的元素，是value=7的节点，按照第一级索引，是不是，2次寻址就可以了。

进一步想，如果，第一个节点所谓的中指针，指向的不是下下个节点，而是，下下下下个节点，比如，上面的**第二级索引**。

那么，查找value=7的节点，第二级索引，是不是1次寻址就可以了。

以此类推，可以增加多级索引了。

![](https://oscimg.oschina.net/oscnet/up-5c3b53ba1bb3d4f3b5d3dfe40f9daa0eea9.png)

这里通过构建多级索引的方式，也就是空间换时间的策略，来提升查询性能。

如上图所示，👆，我们分析一下他的时间复杂度是多少？

**n/2、n/4、n/8、第k级索引结点的个数就是 `n / (2^k)`**
**假设索引有h级，最高级的索引有2个结点。`n / (2^h) = 2`，从而求得h=Iog2(n)-1**

下面是一个跳表查找元素的过程，查找的是第8个位置的元素。

![](https://oscimg.oschina.net/oscnet/up-bc2213f0bb59724892eca3856a66afda08b.png)

索引 的高度是 `logn`, 每层索引遍历的节点个数是： 3

在跳表中查询任意数据的时间复杂度就是O(logn)

**现实中的跳表究竟是什么形态的呢？**

![](https://oscimg.oschina.net/oscnet/up-e7b9359a627785e7b1a85796b5d770cd778.png)

这里并不是非常有规则的索引指向，什么意思呢，就看从上往下第二层索引，每个节点指向下一个节点，中间的个数是不固定的。

跳表在增加/删除一个元素的时候，需要将所有全部更新一遍，所以，跳表的增加/删除的时间复杂度是 O(log(n))；



**跳表的空间复杂度**

![](https://oscimg.oschina.net/oscnet/up-aa1877314b9cd1b1d7d6383781d839aa333.png)



## 思考

Redis zset 为什么使用跳表结构而不是红黑树？